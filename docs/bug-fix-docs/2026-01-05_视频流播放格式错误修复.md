# Bug Fix: 视频流播放格式错误 (MEDIA_ELEMENT_ERROR: Format error)

## 基本信息

| 项目 | 内容 |
|------|------|
| **发现时间** | 2026-01-05 13:55 (UTC+8) |
| **解决时间** | 2026-01-05 14:20 (UTC+8) |
| **修复耗时** | 约 25 分钟 |
| **影响范围** | YouTube/Bilibili 视频无法在应用内播放 |
| **严重程度** | 高 (核心功能不可用) |

---

## Bug 描述

### 现象
用户导入 YouTube 视频后，点击播放时显示错误：
```
Video Error: MEDIA_ELEMENT_ERROR: Format error.
```

视频无法播放，只能看到封面图和字幕列表。

### 复现步骤
1. 在应用中输入 YouTube URL (如 `https://www.youtube.com/watch?v=QztFpzKsdeA`)
2. 点击 Import 按钮
3. 等待视频导入完成 (状态变为 Ready)
4. 点击视频卡片尝试播放
5. 出现格式错误

---

## 根本原因分析

### 问题链条

这个 bug 实际上由 **多个问题叠加** 导致：

#### 1. 缺失 `/media/download` API 端点
- **现象**: 导入视频时报错 "Method Not Allowed"
- **原因**: 前端调用 `POST /media/download`，但后端没有这个端点
- **影响**: 视频无法导入

#### 2. 数据库 Schema 不匹配
- **现象**: 导入时报错 "NOT NULL constraint failed: mediasource.file_path"
- **原因**: `models.py` 中 `file_path` 字段是必填的，但导入时创建占位记录时 `file_path` 为空
- **影响**: 数据库插入失败

#### 3. 视频代理返回的格式不被浏览器支持
- **现象**: 视频导入成功，但播放时报格式错误
- **原因**:
  - YouTube 现在主要返回 HLS (m3u8) 或 DASH 格式的流
  - HTML5 `<video>` 元素无法直接播放 m3u8 格式
  - 原代理逻辑使用 `asyncio.create_subprocess_exec` 调用 yt-dlp 命令行，在 Windows 上失败
  - 后端返回的是原始 YouTube 观看页 URL，而非实际视频流 URL

---

## 修复方案

### 修复 1: 添加 `/media/download` 端点

**文件**: `backend/main.py`

```python
@app.post("/media/download", response_model=MediaSource)
def download_media(
    req: URLRequest,
    background_tasks: BackgroundTasks,
    session: Session = Depends(get_session),
    owner_id: str = Depends(get_current_owner)
):
    """
    Start a background download and processing job for a URL.
    Creates a placeholder MediaSource entry immediately, then processes in background.
    """
    url = req.url

    # Create placeholder entry
    media = MediaSource(
        id=uuid4(),
        title="Importing...",
        source_url=url,
        status="downloading",
        owner_id=owner_id
    )
    session.add(media)
    session.commit()
    session.refresh(media)

    # Queue background processing
    background_tasks.add_task(background_download_and_process, url, str(media.id))

    return media
```

### 修复 2: 允许 `file_path` 为空

**文件**: `backend/models.py`

```python
# 修改前
file_path: str

# 修改后
file_path: Optional[str] = None
```

**数据库迁移** (SQLite 需要重建表):
```python
# 创建新表，复制数据，删除旧表，重命名
cursor.execute('''
CREATE TABLE IF NOT EXISTS mediasource_new (
    ...
    file_path VARCHAR,  -- 移除 NOT NULL
    ...
)
''')
cursor.execute('INSERT INTO mediasource_new SELECT * FROM mediasource')
cursor.execute('DROP TABLE mediasource')
cursor.execute('ALTER TABLE mediasource_new RENAME TO mediasource')
```

### 修复 3: 使用 Python yt-dlp 库获取直接流 URL

**文件**: `backend/main.py`

添加新端点 `/media/stream-url`，使用 `media_service.fetch_metadata()` (内部使用 yt-dlp Python 库) 来解析视频直链：

```python
@app.get("/media/stream-url")
async def get_stream_url(url: str):
    """Resolve a video URL to a direct stream URL."""
    try:
        # 使用 yt-dlp Python 库 (比命令行更可靠)
        metadata = media_service.fetch_metadata(url)
        stream_url = metadata.get('url')

        if stream_url:
            return {"stream_url": stream_url}
        else:
            return {"stream_url": url}

    except Exception as e:
        print(f"ERROR: Failed to resolve stream URL: {e}")
        return {"stream_url": url}
```

### 修复 4: 前端集成 HLS.js 支持 m3u8 播放

**文件**: `src/App.tsx`

```typescript
import Hls from 'hls.js'

// HLS.js 集成
useEffect(() => {
  const video = videoRef.current;
  if (!video || !videoPath) return;

  const isHlsStream = videoPath.includes('.m3u8') || videoPath.includes('manifest');

  if (isHlsStream && Hls.isSupported()) {
    const hls = new Hls();
    hls.loadSource(videoPath);
    hls.attachMedia(video);
    // ...
  }
}, [videoPath]);
```

### 修复 5: 前端先获取直接流 URL 再播放

**文件**: `src/App.tsx`

```typescript
if (media.source_url) {
  // 先从后端获取解析后的直接流 URL
  fetch(`http://localhost:8000/media/stream-url?url=${encodeURIComponent(media.source_url)}`)
    .then(res => res.json())
    .then(data => {
      if (data.stream_url) {
        setVideoPath(data.stream_url);  // 使用直接流 URL
      }
    });
}
```

---

## 技术要点

### 为什么命令行 yt-dlp 在 Windows 上失败？

1. `asyncio.create_subprocess_exec` 在 Windows 上的行为与 Linux 不同
2. 格式选择器中的特殊字符 (`!=`, `^=`) 在 PowerShell 中需要转义
3. Python 的 yt-dlp 库直接调用，避免了 shell 解析问题

### 为什么需要 HLS.js？

- YouTube 已经逐步弃用传统的 progressive MP4 格式
- 大部分视频现在返回 HLS (m3u8) 或 DASH 格式
- Chrome/Firefox 原生不支持 HLS，需要 JavaScript 库来解析

### yt-dlp 的格式选择器

```python
# 用于获取包含视频+音频的直接流 URL
'format': 'best[protocol^=http][protocol!*=m3u8][protocol!*=dash][ext=mp4]/best[ext=mp4]'
```

---

## 验证步骤

1. 启动后端: `cd backend && uvicorn main:app --reload`
2. 启动前端: `npm run dev`
3. 导入 YouTube 视频
4. 确认视频状态变为 "Ready"
5. 点击播放，确认视频正常播放并有声音

---

## 相关文件

| 文件 | 修改类型 |
|------|----------|
| `backend/main.py` | 新增 `/media/download` 和 `/media/stream-url` 端点 |
| `backend/models.py` | `file_path` 改为可选字段 |
| `backend/learning.db` | 数据库迁移 (重建表) |
| `src/App.tsx` | 添加 HLS.js 集成和流 URL 获取逻辑 |
| `package.json` | 新增 `hls.js` 依赖 |

---

## 后续优化建议

1. **缓存流 URL**: 流 URL 通常有时效性 (几小时)，可以考虑缓存并在过期前刷新
2. **错误重试**: 当流 URL 失效时，自动重新获取
3. **格式偏好设置**: 允许用户选择偏好的视频质量
4. **离线模式**: 考虑下载完整视频而非仅音频，支持离线播放
