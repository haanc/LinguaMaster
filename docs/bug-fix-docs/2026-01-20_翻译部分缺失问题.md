# Bug Fix: 批量翻译部分片段缺失

## 基本信息

| 项目 | 内容 |
|------|------|
| **发现时间** | 2026-01-20 20:12 (UTC+8) |
| **解决时间** | 2026-01-20 20:24 (UTC+8) |
| **修复耗时** | 约 12 分钟 |
| **影响范围** | 字幕翻译功能 - 部分字幕片段无法显示翻译 |
| **严重程度** | 中 |

---

## Bug 描述

### 现象
用户导入 YouTube 视频后，启用翻译功能时，部分字幕片段显示了中文翻译，但另一部分片段只显示英文原文，没有翻译。

具体表现：
- 69 个字幕片段中，42 个有翻译，27 个没有翻译
- 缺失的翻译呈现间隔分布（如 index 0 无翻译，1 有，2 无，3 有...）

### 复现步骤
1. 导入 YouTube 视频 (例如: https://www.youtube.com/watch?v=dTFzdmG7E2E)
2. 等待视频转录完成
3. 点击翻译按钮，选择目标语言为中文
4. 观察字幕列表，发现部分片段没有中文翻译

---

## 根本原因分析

问题出在 `ai_service.py` 的 `translate_batch` 函数中的响应解析逻辑：

1. **原逻辑假设**：代码假设 LLM 返回的翻译使用 `---` 分隔符分割各个翻译
2. **实际情况**：LLM (gpt-5.2-chat) 实际返回的格式是连续的 `[number] translation` 格式，没有使用 `---` 分隔符
3. **解析失败**：当 LLM 返回类似 `[0] 翻译1\n[1] 翻译2\n[2] 翻译3...` 的格式时，原逻辑只能解析到第一个翻译，后续的都被忽略

原代码逻辑：
```python
# 按 --- 分割
segments = result_text.split("---")
for segment in segments:
    if segment.startswith("["):
        # 只能解析第一行
        idx_end = segment.index("]")
        idx = int(segment[1:idx_end])
        translation = segment[idx_end + 1:].strip()
```

当 LLM 不返回 `---` 分隔符时，整个响应作为一个 segment，然后只有第一个 `[0]` 被解析。

---

## 修复方案

### 修复 1: 改进 LLM Prompt

**文件**: `backend/ai_service.py`

```python
# 修改前
system_prompt = (
    f"You are a translator. Translate each numbered subtitle segment to {target_language}. "
    "Keep the [number] prefix in your response. Only output translations, no explanations."
)

# 修改后
system_prompt = (
    f"You are a translator. Translate each numbered subtitle segment to {target_language}. "
    "Keep the [number] prefix in your response. Output one translation per line in format: [number] translation"
)
```

明确要求 LLM 使用 `[number] translation` 格式，每行一个翻译。

### 修复 2: 使用正则表达式解析

**文件**: `backend/ai_service.py`

```python
# 修改前：基于分隔符的不可靠解析
segments = result_text.split("---")
for segment in segments:
    if segment.startswith("["):
        idx_end = segment.index("]")
        # ...

# 修改后：使用正则表达式匹配所有翻译对
import re

pattern = r'\[(\d+)\]\s*([^\[]+)'
matches = re.findall(pattern, result_text, re.DOTALL)

for idx_str, translation in matches:
    idx = int(idx_str)
    translation = translation.strip().rstrip('-').strip()
    if translation:
        all_translations[idx] = translation
```

正则表达式 `\[(\d+)\]\s*([^\[]+)` 解释：
- `\[(\d+)\]` - 匹配 `[数字]` 并捕获数字
- `\s*` - 匹配任意空白字符
- `([^\[]+)` - 匹配直到下一个 `[` 之前的所有内容（即翻译文本）

这种方式可以可靠地处理各种 LLM 响应格式，无论是否有分隔符。

---

## 技术要点

1. **LLM 输出不确定性**：不同的 LLM 模型可能返回不同格式的响应，代码需要足够健壮来处理各种格式
2. **正则表达式的优势**：使用正则可以一次性匹配所有符合模式的内容，比逐行解析更可靠
3. **re.DOTALL 标志**：允许 `.` 匹配换行符，确保跨行的翻译也能被正确捕获

---

## 验证步骤

1. 启动开发环境（后端 8000，前端 5173）
2. 导入一个新的 YouTube 视频或使用已有视频
3. 启用翻译功能，选择目标语言
4. 确认所有字幕片段都显示了翻译（无遗漏）
5. 检查后端日志，确认 `parsed X/Y segments` 显示完整解析

---

## 相关文件

| 文件 | 修改类型 |
|------|----------|
| `backend/ai_service.py` | 修改 |

---

## 后续优化建议

1. **添加解析验证**：如果解析率低于某个阈值（如 80%），自动重试或使用备用解析策略
2. **日志增强**：当解析失败时，记录 LLM 原始响应以便调试
3. **单元测试**：添加针对不同 LLM 响应格式的单元测试，确保解析逻辑的健壮性
