# Bug Fix: 后台转录任务中断导致媒体卡死 (Media stuck in "transcribing" status)

## 基本信息

| 项目 | 内容 |
|------|------|
| **发现时间** | 2026-01-05 14:31 (UTC+8) |
| **解决时间** | 2026-01-05 15:03 (UTC+8) |
| **修复耗时** | 约 32 分钟 |
| **影响范围** | 导入的视频卡在 "transcribing" 状态，无法生成字幕 |
| **严重程度** | 中 (核心功能受影响，但可通过重新导入恢复) |

---

## Bug 描述

### 现象
用户导入 YouTube 视频后，视频状态一直显示 "transcribing"（转录中），长时间无法完成处理，也没有生成字幕。前端持续轮询后端 API，但媒体状态始终不更新为 "ready"。

### 复现步骤
1. 导入一个 YouTube 视频 (如 `https://www.youtube.com/watch?v=Fv2pv62uXdU`)
2. 等待下载完成，状态变为 "transcribing"
3. 在转录过程中，**重启后端服务器** (如 `Ctrl+C` 后重新启动 uvicorn)
4. 刷新页面，发现媒体状态仍为 "transcribing"
5. 等待任意长时间，状态都不会改变

---

## 根本原因分析

### 问题核心：FastAPI BackgroundTasks 是内存级的

FastAPI 的 `BackgroundTasks` 是**非持久化**的后台任务机制：

```python
background_tasks.add_task(background_download_and_process, url, str(media.id))
```

当服务器重启时：
1. 所有正在运行的后台任务被**立即终止**
2. 任务队列**完全丢失**（没有持久化到数据库或消息队列）
3. 数据库中的媒体状态仍然是 `transcribing`，但没有进程在处理它
4. 系统没有自动恢复机制，媒体永远卡在中间状态

### 问题链条

```
服务器重启
    ↓
后台任务队列清空
    ↓
正在执行的转录任务被终止
    ↓
数据库状态未更新（仍为 transcribing）
    ↓
没有任何进程继续处理这个任务
    ↓
媒体永久卡死
```

---

## 修复方案

### 修复 1: 添加手动重新转录端点

**文件**: `backend/main.py`

新增 `/media/{media_id}/retranscribe` 端点，允许用户手动触发重新转录：

```python
def background_transcribe_only(audio_path: str, media_id_str: str):
    """
    Transcribe audio only (for re-triggering stuck jobs).
    """
    media_id = UUID(media_id_str)

    with Session(engine) as db:
        try:
            media = db.get(MediaSource, media_id)
            if not media:
                print(f"ERROR: Media {media_id} not found in transcribe task.")
                return

            print(f"DEBUG: Starting transcription for {audio_path}...")
            media.status = 'transcribing'
            db.add(media)
            db.commit()

            segments_data = ai_service.transcribe_audio(audio_path)
            print(f"DEBUG: Transcription complete. {len(segments_data)} segments.")

            # Save segments
            for seg in segments_data:
                db_seg = SubtitleSegment(
                    media_id=media.id,
                    index=seg['index'],
                    start_time=seg['start_time'],
                    end_time=seg['end_time'],
                    text=seg['text']
                )
                db.add(db_seg)

            media.status = 'ready'
            db.add(media)
            db.commit()
            print(f"DEBUG: Media {media_id} ready with {len(segments_data)} segments.")

        except Exception as e:
            print(f"ERROR in background_transcribe_only: {e}")
            media.status = 'error'
            media.error_message = str(e)
            db.add(media)
            db.commit()
```

```python
@app.post("/media/{media_id}/retranscribe", response_model=MediaSource)
def retranscribe_media(
    media_id: UUID,
    background_tasks: BackgroundTasks,
    session: Session = Depends(get_session)
):
    """
    Manually re-trigger transcription for a stuck media.
    Useful when background task was interrupted (e.g., server restart).
    """
    media = session.get(MediaSource, media_id)
    if not media:
        raise HTTPException(status_code=404, detail="Media not found")

    if not media.file_path or not os.path.exists(media.file_path):
        raise HTTPException(status_code=400, detail="Audio file not found. Please re-import the video.")

    # Clear any existing segments (avoid duplicates)
    existing_segments = session.exec(
        select(SubtitleSegment).where(SubtitleSegment.media_id == media_id)
    ).all()
    for seg in existing_segments:
        session.delete(seg)

    media.status = 'transcribing'
    media.error_message = None
    session.add(media)
    session.commit()
    session.refresh(media)

    # Queue transcription
    background_tasks.add_task(background_transcribe_only, media.file_path, str(media.id))

    return media
```

### 设计要点

1. **验证音频文件存在**: 只有当 `file_path` 存在且文件确实在磁盘上时，才允许重新转录
2. **清理现有字幕**: 防止重复转录导致字幕段重复
3. **独立的转录函数**: `background_transcribe_only` 只负责转录步骤，跳过下载和元数据获取
4. **错误处理**: 转录失败时将状态设为 `error` 并记录错误信息

---

## 技术要点

### 为什么 FastAPI BackgroundTasks 不持久化？

FastAPI 的 `BackgroundTasks` 设计初衷是处理**短期、不关键**的后台任务，如：
- 发送邮件通知
- 记录审计日志
- 清理临时文件

对于**长时间运行、关键**的任务（如视频转录），更好的选择是：
- **Celery + Redis/RabbitMQ**: 分布式任务队列，支持任务持久化和重试
- **Dramatiq + Redis**: 轻量级替代方案
- **ARQ**: 基于 Redis 的异步任务队列

### Azure OpenAI Whisper 转录流程

```
音频文件 (MP3)
    ↓
ai_service.transcribe_audio(audio_path)
    ↓
Azure OpenAI Whisper API
    ↓
返回带时间戳的字幕段
    ↓
保存到 SubtitleSegment 表
```

### 前端轮询机制

前端通过 TanStack Query 每 2 秒轮询 `/media` 端点：

```typescript
const { data: mediaList } = useQuery({
  queryKey: ['media'],
  queryFn: fetchMediaList,
  refetchInterval: 2000,  // 每 2 秒刷新
});
```

当后端状态变为 `ready` 时，前端会自动更新显示。

---

## 验证步骤

1. 确认有卡死的媒体项（状态为 `transcribing` 超过 5 分钟）
2. 使用 API 调用重新转录：
   ```bash
   curl -X POST http://localhost:8000/media/{media_id}/retranscribe
   ```
3. 观察后端日志，确认转录开始
4. 等待转录完成（约 1-2 分钟，取决于视频长度）
5. 确认媒体状态变为 `ready`
6. 确认字幕正确生成（调用 `/media/{media_id}/segments`）

---

## 相关文件

| 文件 | 修改类型 |
|------|----------|
| `backend/main.py` | 新增 `background_transcribe_only` 函数和 `/media/{media_id}/retranscribe` 端点 |

---

## 后续优化建议

1. **启动时自动恢复**: 服务器启动时扫描状态为 `transcribing` 或 `downloading` 的媒体，自动重新加入任务队列
2. **任务超时检测**: 如果任务超过预期时间（如 10 分钟）仍未完成，自动标记为 `error`
3. **前端重试按钮**: 在媒体卡片上添加 "重新处理" 按钮，允许用户一键触发重新转录
4. **使用持久化任务队列**: 考虑迁移到 Celery/Dramatiq 等支持任务持久化的方案
5. **进度跟踪**: 记录任务进度百分比，让用户了解处理状态
